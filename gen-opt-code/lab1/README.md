ah sh_t here we go again
## ТЗ  Lab #1

Выполнить распечатку GIMPLE/IR из gcc компилятора. Например, это можно сделать из ./gcc-4.9.0/gcc/tree-ssa-dce.c.   (4.9.0 или другая версия). Как вариант, можно сделать распечатку из плагина для GCC. На ваше усмотрение.
 

Эта распечатка должна в себя включать следующее:  
    * базовые блоки, блоки-предшественники, блоки-последователи  
    * содержимое базовых блоков (GIMPLE инструкции):
                  - арифметические операции  
                  - Ф-функции  
                  - инструкции ветвления  
                  - выражения доступа в память (ArrayRef и др)  
  

## Запуск
```make lab1``` - создает плагин lab1.so
```make test``` - запускает тест src/test.c с помощью созданного lab1.so и выводит в консоль все блоки и gimple конструкции

дальше можно сказать, что ты умничка, и вывести еще граф с ssa формой
```gcc -fdump-tree-ssa-graph src/test.c```  
после этого создается файлик например, ```test.c.021t.ssa.dot```  

```dot -Tpng test.c.021t.ssa.dot > out.png``` - создаем пнг картинку с ssa формой


## Спойлер для всех тех, кто помладше и забрел сюда
**В целом надо показать преподу (попытаться), что ты делал плагин сам и знаешь, что происходит)**  
Для достижения этой цели мой исходник в архиве содержит комментарии (гпт спасибо) и не содержит лишних функций и кейсов (в изначальном [плагине](https://github.com/masyagin1998/gcc-plugin-guide) их побольше, в гайде в целом все опсиано - за что большое спасибо)

FAQ:  
- если будет вопрос про SSA_NAME_DEF_STMT (это где реализован printf GIMPLE-PHI)
то это макрос, который на вход берет ноду дерева и на выходе дает указатель на инструкцию, которая определяет SSA_NAME текущего узла
если коротко просто указатель на SSA_NAME текущего узла дерева  
- еще он часто тыкает в вывод в консоль после make test, тыкает например где GIMPLE_ASSIGN и просит показать, где это реализовано в коде 
- многих спрашивал, где ArrayRef реализован  

Так или иначе, все сдается и забывается ^^
